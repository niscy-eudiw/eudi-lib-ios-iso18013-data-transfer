import Foundation
import MdocDataModel18013
import MdocSecurity18013
import struct WalletStorage.Document

public struct InitializeTransferData: Sendable {

	public init(dataFormats: [String: String], documentData: [String: Data], documentKeyIndexes: [String: Int], docMetadata: [String: Data?], docDisplayNames: [String: [String: [String: String]]?], docKeyInfos: [String: Data?], trustedCertificates: [Data], deviceAuthMethod: String, idsToDocTypes: [String: String], hashingAlgs: [String: String], zkSystemRepository: ZkSystemRepository? = nil) {
        self.dataFormats = dataFormats
        self.documentData = documentData
		self.documentKeyIndexes = documentKeyIndexes
		self.docMetadata = docMetadata
		self.docDisplayNames = docDisplayNames
        self.docKeyInfos = docKeyInfos
        self.trustedCertificates = trustedCertificates
        self.deviceAuthMethod = deviceAuthMethod
        self.idsToDocTypes = idsToDocTypes
		self.hashingAlgs = hashingAlgs
        self.zkSystemRepository = zkSystemRepository
    }
    /// doc-id to data format
    public let dataFormats: [Document.ID: String]
    /// doc-id to document data
    public let documentData: [Document.ID: Data]
	/// doc-id to document key indexes
	public let documentKeyIndexes: [Document.ID: Int]
	/// document-id to doc-metadata map
	public let docMetadata: [Document.ID: Data?]
	/// document-id to doc.fields display names
	public let docDisplayNames: [Document.ID: [String: [String: String]]?]
    /// doc-id to private key info
    public let docKeyInfos: [Document.ID: Data?]
    /// trusted certificates
    public let trustedCertificates: [Data]
    /// device auth method
    public let deviceAuthMethod: String
    /// document-id to document type map
    public let idsToDocTypes: [String: String]
	/// document-id to hashing algorithm
	var hashingAlgs: [String: String]
    // optional zk system repository
    public let zkSystemRepository: ZkSystemRepository?

    public func toInitializeTransferInfo() -> InitializeTransferInfo {
        // filter data and private keys by format
		let privateKeyObjects: [String: CoseKeyPrivate] = Dictionary(uniqueKeysWithValues: docKeyInfos.compactMap {
			guard let dki = DocKeyInfo(from: $0.value)  else { return nil }
			guard let keyIndex = documentKeyIndexes[$0.key] else { return nil }
			return ($0.key, CoseKeyPrivate(privateKeyId: $0.key, index: keyIndex, secureArea: SecureAreaRegistry.shared.get(name: dki.secureAreaName)))
		})
		let documentObjects = documentData
		let docMetadata = docMetadata.compactMapValues { $0 }
		let dataFormats = Dictionary(uniqueKeysWithValues: dataFormats.map { k,v in (k, DocDataFormat(rawValue: v)) }).compactMapValues { $0 }
        let iaca = trustedCertificates.map { SecCertificateCreateWithData(nil, $0 as CFData)! }
        let deviceAuthMethod = DeviceAuthMethod(rawValue: deviceAuthMethod) ?? .deviceMac
		return InitializeTransferInfo(dataFormats: dataFormats, documentObjects: documentObjects, docMetadata: docMetadata, docDisplayNames: docDisplayNames, privateKeyObjects: privateKeyObjects, iaca: iaca, deviceAuthMethod: deviceAuthMethod, idsToDocTypes: idsToDocTypes, hashingAlgs: hashingAlgs, zkSystemRepository: zkSystemRepository)
    }
}

public struct InitializeTransferInfo {
    /// doc-id to data format
    public let dataFormats: [Document.ID: DocDataFormat]
    /// doc-id to document objects
    public let documentObjects: [Document.ID: Data]
	/// document-id to doc-metadata map
	public let docMetadata: [Document.ID: Data]
	/// doc-id to doc.fields display names
	public let docDisplayNames: [Document.ID: [String: [String: String]]?]
    /// doc-id to private key objects
    public let privateKeyObjects: [Document.ID: CoseKeyPrivate]
    /// trusted certificates
    public let iaca: [SecCertificate]
    /// device auth method
    public let deviceAuthMethod: DeviceAuthMethod
	// document-id to document type map
    public let idsToDocTypes: [Document.ID: DocType]
	// document-id to hashing algorithm
	public let hashingAlgs:[Document.ID: String]
    // optional zk system repository
    public let zkSystemRepository: ZkSystemRepository?
}
